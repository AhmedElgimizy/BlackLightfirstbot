const Discord = require('discord.js');
const client = new Discord.Client();
const prefix = 'BL!'

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
client.user.setGame(`Nothing`,"http://twitch.tv/S-F")
  console.log('')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•—')
  console.log(`[Start] ${new Date()}`);
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•—');
  console.log(`Logged in as * [ " ${client.user.username} " ]`);
  console.log('')
  console.log('Informations :')
  console.log('')
  console.log(`servers! [ " ${client.guilds.size} " ]`);
  console.log(`Users! [ " ${client.users.size} " ]`);
  console.log(`channels! [ " ${client.channels.size} " ]`);
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•]â•—')
  console.log(' Bot Is Online')
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('')
});
const adminprefix = "BL!";
const devs = ['347379495528824832'];
client.on('message', message => {
  var argresult = message.content.split(` `).slice(1).join(' ');
    if (!devs.includes(message.author.id)) return;
    
if (message.content.startsWith(adminprefix + 'setgame')) {
  client.user.setGame(argresult);
    message.channel.sendMessage(`**${argresult} ØªÙ… ØªØºÙŠÙŠØ± Ø¨Ù„Ø§ÙŠÙ†Ù‚ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰ **`)
} else 
  if (message.content.startsWith(adminprefix + 'setname')) {
client.user.setUsername(argresult).then
    message.channel.sendMessage(`**${argresult}** : ØªÙ… ØªØºÙŠÙŠØ± Ø£Ø³Ù… Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰`)
return message.reply("**Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø§Ù„Ø§Ø³Ù… ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ù†ØªØ¸Ø¢Ø± Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹ØªÙŠÙ† . **");
} else
  if (message.content.startsWith(adminprefix + 'avatar')) {
client.user.setAvatar(argresult);
  message.channel.sendMessage(`**${argresult}** : ØªÙ… ØªØºÙŠØ± ØµÙˆØ±Ø© Ø§Ù„Ø¨ÙˆØª`);
      } else     
if (message.content.startsWith(adminprefix + 'setT')) {
  client.user.setGame(argresult, "https://www.twitch.tv/idk");
    message.channel.sendMessage(`**ØªÙ… ØªØºÙŠÙŠØ± ØªÙˆÙŠØªØ´ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰  ${argresult}**`)
}
});

client.on('message', message => {
if (message.content.startsWith(prefix + 'help')) { //ALPHACODES
    let pages = [`
***__ÙˆØµÙ Ø¹Ù† Ø§Ù„Ø¨ÙˆØª__***
**
:gem:  Ø§Ù„Ø¨ÙˆØª ÙÙŠÙ‡ ÙƒØ«ÙŠØ± Ù…ÙŠØ²Ø§Øª Ø­Ù„ÙˆØ© Ùˆ Ø¬Ù…ÙŠÙ„Ø©
 Ø§:rocket: Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ 24 Ø³Ø§Ø¹Ù‡ 
Ø¨ÙˆØª ÙŠÙ…ØªÙ„Ùƒ Ù…Ø¶Ø¯ Ø¬Ø­ÙÙ„Ù‡ +Ø³Ø¨Ø§Ù…+Ù†Ø´Ø± Ø±ÙˆØ§Ø¨Ø·+Ù…Ø¶Ø§Ø¯ Ø³Ø¨ :gear: 
**
        ***__General orders__***
**
ã€!allbots/Ù„Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„ÙŠ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€!server/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€!bot/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ ÙƒÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØªã€
ã€!skin <name>/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ø³ÙƒÙ†Ùƒ Ø¨Ù…Ø§ÙŠÙ† ÙƒØ±Ø§ÙØªã€
ã€!count/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± Ø¨Ø¯ÙˆÙ† Ø¨ÙˆØªØ§Øªã€
ã€!invites/ ÙŠØ¹Ø±Ø¶ Ù„Ùƒ  Ø¹Ø¯Ø¯ Ø§Ù†ÙØ§ÙŠØªØ§ØªÙƒ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± ã€
ã€!invite-codes/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø§Ù†ÙØ§ÙŠØªØ§Øª Ø­ÙƒÙƒ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± ã€
ã€!cal/Ø§Ù„Ù‡ Ø­Ø§Ø³Ø¨Ø©ã€
ã€!trans <language> <any thing>/ÙŠØªØ±Ø¬Ù… Ù„Ùƒ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ Ù…Ù† Ø§ÙŠ Ù„ØºØ©ã€
ã€!short/ÙŠØ®ØªØµØ± Ù„Ùƒ Ø±Ø§Ø¨Ø· ÙƒØ¨ÙŠØ± Ø§Ù„Ù‰ Ø±Ø§Ø¨Ø· ØµØºÙŠØ±ã€
ã€!tag/ÙŠÙƒØªØ¨ Ù„Ùƒ Ø§Ù„ÙƒÙ„Ù…Ø© Ø¨Ø´ÙƒÙ„ Ø¬Ù…ÙŠÙ„ ÙˆÙƒØ¨ÙŠØ±ã€
ã€!google/Ù„Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚ÙˆÙ‚Ù„ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø¯Ø³ÙƒÙˆØ±Ø¯ã€
ã€!perms/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ø¨Ø±Ù…Ø´Ù†Ø§ØªÙƒ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€!yn/ØªØ³Ø£Ù„ Ø¨ÙˆØª ÙˆØ§Ù„Ø¨ÙˆØª ÙŠØ¬Ø§ÙˆØ¨Ùƒ Ø¨Ù†Ø¹Ù… Ø§Ùˆ Ù„Ø§ã€
ã€!w/Ø§Ù…Ø± ÙŠØ®Ù„ÙŠÙƒ Ù…Ø«Ù„ Ø¨ÙˆØª ØªÙƒØªØ¨ Ø¹Ø¨Ø±Ù‡ Ù…Ø¹ Ø§Ù…Ø± ÙˆÙŠØ³ÙˆÙŠÙƒ Ø¨ÙˆØªã€
ã€!za5/ÙŠØ²Ø®Ø±Ù Ù„Ùƒ ÙƒÙ„Ù…Ø© Ø§Ùˆ Ø¬Ù…Ù„Ø©ã€
ã€!rooms/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ ÙƒÙ„ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ÙŠ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± Ù…Ø¹ Ø¹Ø¯Ø¯Ù‡Ø§ã€
ã€!roles/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ ÙƒÙ„ Ø§Ù„Ø±Ø§Ù†ÙƒØ§Øª Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± Ø¨Ø´ÙƒÙ„ Ø¬Ù…ÙŠÙ„ã€
ã€!emojilist/ÙŠØ¹Ø±Ø¶ Ù„Ùƒ ÙƒÙ„ Ø§Ù„Ø§ÙŠÙ…ÙˆØ¬ÙŠØ§Øª Ø§Ù„ÙŠ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€say/ÙŠÙƒØ±Ø± Ø§Ù„ÙƒÙ„Ø§Ù… Ø§Ù„ÙŠ ØªÙƒØªØ¨Ùˆã€
ã€!image/ØµÙˆØ±Ø© Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€!members/ï¿½ï¿½Ø¹Ø±Ø¶ Ù„Ùƒ Ø¹Ø¯Ø¯ ÙƒÙ„ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø§Ø´Ø®Ø§Øµ ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµã€
ã€!id/Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù†Ùƒã€
ã€!profile/Ø¹Ø±Ø¶ Ø¨Ø±ÙˆÙØ§ÙŠÙ„ Ø­Ù‚Ùƒã€
ã€!tc/Ø§Ù†Ø´Ø§Ø¡ Ø±ÙˆÙ… Ù…Ø¤Ù‚Øª ÙˆÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø¹Ø¯Ø§Ø¯Ø§Øªã€
ã€!bans / Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ù…Ø¨Ù†Ø¯Ø© ã€
ã€!voice /  ÙŠÙˆÙ… Ù„Ùƒ Ø¨ÙƒØªØ§Ø¨Ù‡ Ù…Ø¬Ù…ÙˆØ¹ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ† Ø¨Ø±ÙˆÙ…Ø§Øªã€
ã€!avatar/ØµÙˆØ±ØªÙƒ Ø§Ùˆ ØµÙˆØ±Ø© Ø§Ù„ÙŠ ØªÙ…Ù†Ø´Ù†Ùˆã€
ã€!embed/ÙŠÙƒØ±Ø± Ø§Ù„ÙŠ ØªÙ‚ÙˆÙ„Ùˆ Ø¨Ø´ÙƒÙ„ Ø­Ù„Ùˆã€
ã€!discrim/ÙƒÙˆØ¯ ÙŠØ¶Ù‡Ø± Ù„Ùƒ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ù†ÙØ³ ØªØ§Ù‚Ùƒã€
ã€!emoji <any things>/Ù„ØªØ­ÙˆÙŠÙ„ Ø§ÙŠ ÙƒÙ„Ù…Ù‡ ØªÙ‚ÙˆÙ„Ù‡Ø§ Ø§Ù„ÙŠ Ø§ÙŠÙ…ÙˆØ¬ÙŠã€
ã€!inv/Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‰ Ø³ÙŠØ±ÙØ±Ùƒã€
ã€!support/Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯Ø¹Ù…ã€
ã€!contact/Ø§Ø±Ø³Ø§Ù„ Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ùˆ Ù„Ù…Ø±Ø§Ø³Ù„Ø© ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØªã€
**
  `
,`
        ***__Administrative Orders__***
**
ã€!move @user /  Ù„Ø³Ø­Ø¨ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù‰ Ø±ÙˆÙˆÙ…Ùƒã€
ã€!voiceonline /  Ù„ØªÙØ¹ÙŠÙ„ Ø®Ø§ØµÙŠÙ‡ ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ† ÙŠØ³Ø­Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ† Ø¨Ø±ÙˆÙ…Ø§Øªã€
ã€!bc / Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ© Ø§Ù„Ù‰ ÙƒÙ„ Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€!bcrole / Ù„Ø§Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ù‡ Ø¬Ù…Ø§Ø¹ÙŠ Ù„Ø±ØªØ¨Ù‡ Ù…Ø­Ø¯Ø¯Ù‡ ÙŠØ¬Ø¨ ØªÙ…Ù†Ø´Ù†Ù‡Ø§ ã€
ã€!role @user <rank> / Ù„Ø£Ø¹Ø·Ø§Ø¡ Ø±ØªØ¨Ø© Ù„Ø¹Ø¶Ùˆ Ù…Ø¹ÙŠÙ†ã€
ã€!roleremove @user <rank> / Ù„Ø§Ø²Ø§Ù„Ø© Ø§Ù„Ø±ØªØ¨Ø© Ù…Ù† Ø´Ø®Øµ Ù…Ø¹ÙŠÙ†ã€
ã€!role all <rank> / Ù„Ø£Ø¹Ø·Ø§Ø¡ Ø±ØªØ¨Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹ã€
ã€!role humans <rank> / Ù„Ø£Ø¹Ø·Ø§Ø¡ Ø±ØªØ¨Ø© Ù„Ù„Ø§Ø´Ø®Ø§Øµ ÙÙ‚Ø·ã€
ã€!role bots <rank> / Ù„Ø£Ø¹Ø·Ø§Ø¡ Ø±ØªØ¨Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øªã€
ã€!hchannel / Ø§Ø®ÙØ§Ø¡ Ø§Ù„Ø´Ø§Øªã€
ã€!schannel / Ø§Ø¶Ù‡Ø§Ø± Ø§Ù„Ø´Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ©ã€
ã€!clr <numbr> / Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª Ø¨Ø¹Ø¯Ø¯ã€
ã€!clear / Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øªã€
ã€!mute @user <reason> / Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¹Ø¶Ùˆ Ù…ÙŠÙˆØª Ù„Ø§Ø²Ù… Ø±ØªØ¨Ø© <Muted>ã€
ã€!unmute @user / Ù„ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù† Ø§Ù„Ø´Ø®Øµ ã€
ã€!kick @user <reason> / Ø·Ø±Ø¯ Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€!ban @user <reason> / Ø­Ø¶Ø± Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±ã€
ã€!mutechannel / ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øªã€
ã€!unmutechannel / ÙØªØ­ Ø§Ù„Ø´Ø§Øªã€
ã€!dc / Ù…Ø³Ø­ ÙƒÙ„ Ø§Ù„Ø±ÙˆÙ…Ø§Øªã€
ã€!dr / <Ù…Ø³Ø­ ÙƒÙ„ Ø§Ù„Ø±Ø§Ù†ÙƒØ§Øª <Ù„Ø§Ø²Ù… ØªÙƒÙˆÙ† Ø±Ø§Ù†Ùƒ Ø§Ù„Ø¨ÙˆØª ÙÙˆÙ‚ ÙƒÙ„ Ø§Ù„Ø±Ø§Ù†ÙƒØ§Øªã€
ã€!ct <name> / Ø§Ù†Ø´Ø§Ø¡ Ø´Ø§Øªã€
ã€!cv <name> / Ø§Ù†Ø´Ø§Ø¡ Ø±ÙˆÙˆÙ… ÙÙˆÙŠØ³ã€
ã€!delet <name> / Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª Ø§Ùˆ Ø§Ù„Ø±ÙˆÙˆÙ… ÙÙˆÙŠØ³ã€
ã€â–!ccolors <number> / ÙŠÙ†Ø´Ø§ Ù„Ùƒ Ø§Ù„ÙˆØ§Ù† Ù…Ø¹ ÙƒÙ… Ø§Ù„ÙˆØ§Ù† ØªØ¨ÙŠã€
   `,`
        ***__Music orders__***
**
ã€${prefix}play / Ù„ØªØ´ØºÙŠÙ„ Ø£ØºÙ†ÙŠØ© Ø¨Ø±Ø¢Ø¨Ø· Ø£Ùˆ Ø¨Ø£Ø³Ù…ã€
ã€${prefix}skip / Ù„ØªØ¬Ø¢ÙˆØ² Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„Ø­Ø¢Ù„ÙŠØ©ã€
ã€${prefix}pause / Ø¥ÙŠÙ‚Ø¢Ù Ø§Ù„Ø£ØºÙ†ÙŠØ© Ù…Ø¤Ù‚ØªØ§ã€
ã€${prefix}resume / Ù„Ù…ÙˆØ¢ØµÙ„Ø© Ø§Ù„Ø¥ØºÙ†ÙŠØ© Ø¨Ø¹Ø¯ Ø¥ÙŠÙ‚Ø¢ÙÙ‡Ø¢ Ù…Ø¤Ù‚ØªØ§ã€
ã€${prefix}vol / Ù„ØªØºÙŠÙŠØ± Ø¯Ø±Ø¬Ø© Ø§Ù„ØµÙˆØª 100 - 0ã€
ã€${prefix}stop / Ù„Ø¥Ø®Ø±Ø¢Ø¬ Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ø§Ù„Ø±ÙˆÙ…ã€
ã€${prefix}np / Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„Ù…Ø´ØºÙ„Ø© Ø­Ø¢Ù„ÙŠØ§ã€
ã€${prefix}queue / Ù„Ù…Ø¹Ø±ÙØ© Ù‚Ø¢Ø¦Ù…Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ã€
**
        ***__Games orders__***
 **       
ã€!rps / Ø­Ø¬Ø± ÙˆØ±Ù‚Ø© Ù…Ù‚Øµã€
ã€!speed / Ø§Ø³Ø±Ø¹ ÙƒØªØ§Ø¨Ø©ã€
ã€!quas / Ø§Ø³Ø¦Ù„Ø© Ø¹Ø§Ù…Ø©ã€
ã€!Ù†ÙƒØª / Ù†ÙƒØª ã€
ã€!Ù„Ø¹Ø¨Ø© ÙÙƒÙƒ / ÙÙƒÙƒã€
ã€!Ø¹ÙˆØ§ØµÙ… Ø¹Ø´ÙˆØ§Ø¦ÙŠ/Ø¹ÙˆØ§ØµÙ…ã€
ã€!Ù„Ø¹Ø¨Ø© ÙƒØª ØªÙˆÙŠØª / ÙƒØª ØªÙˆÙŠØªã€
ã€!roll <number> / Ù‚Ø±Ø¹Ø©ã€
ã€!Ù„Ùˆ Ø®ÙŠØ±ÙˆÙƒ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø­Ù„ÙˆØ© / Ù„Ùˆ Ø®ÙŠØ±ÙˆÙƒã€
ã€!Ù„Ø¹Ø¨Ø© Ù…Ø±ÙŠÙ… / Ù…Ø±ÙŠÙ…ã€
ã€!ÙÙˆØ§Ø¦Ø¯ ÙˆÙ†ØµØ§Ø¦Ø­  / Ù‡Ù„ ØªØ¹Ù„Ù…ã€
ã€!ÙŠØ¹Ø·ÙŠÙƒ Ø¹Ù‚Ø§Ø¨Ø§Øª Ù‚Ø§Ø³ÙŠØ© / Ø¹Ù‚Ø§Ø¨ ã€


**
   
`]
    let page = 1;

    let embed = new Discord.RichEmbed()
    .setColor('RANDOM')
    .setFooter(`Page ${page} of ${pages.length}`)
    .setDescription(pages[page-1])

    message.author.sendEmbed(embed).then(msg => {

        msg.react('â—€').then( r => {
            msg.react('â–¶')


        const backwardsFilter = (reaction, user) => reaction.emoji.name === 'â—€' && user.id === message.author.id;
        const forwardsFilter = (reaction, user) => reaction.emoji.name === 'â–¶' && user.id === message.author.id;


        const backwards = msg.createReactionCollector(backwardsFilter, { time: 2000000});
        const forwards = msg.createReactionCollector(forwardsFilter, { time: 2000000});



        backwards.on('collect', r => {
            if (page === 1) return;
            page--;
            embed.setDescription(pages[page-1]);
            embed.setFooter(`Page ${page} of ${pages.length}`);
            msg.edit(embed)
        })
        forwards.on('collect', r => {
            if (page === pages.length) return;
      
      page++;
            embed.setDescription(pages[page-1]);
            embed.setFooter(`Page ${page} of ${pages.length}`);
            msg.edit(embed)
        })
        })
    })
    }
});

client.on('guildMemberAdd', member => {
    var embed = new Discord.RichEmbed()
    .setThumbnail(member.user.avatarURL)
  .addField("***Ø´ÙƒØ±Ø§ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…Ùƒ Ø§Ù„ÙŠÙ†Ø§***" ,member.user.username )
    .setDescription('***Ø¨ÙƒÙ„ Ø­Ø¨ ÙˆØ§Ø­ØªØ±Ø§Ù… ÙˆØ´ÙˆÙ‚ Ù†Ø³ØªÙ‚Ø¨Ù„Ùƒ ÙˆÙ†ØªÙ…Ù†Ù‰ Ù„Ùƒ Ù‚Ø¶Ø¢Ø¡ Ø£Ø¬Ù…Ù„ Ø§Ù„Ù„Ø­Ø¸Ø§Øª ÙˆÙ„Ø¢ÙˆÙ‚Ø§Øª Ù…Ø¹Ù†Ø§***')
    .setColor('RANDOM')
    .setImage('http://www.imgion.com/images/01/Welcome-buddy.jpg')
var channel =member.guild.channels.find('name', 'welcome')
if (!channel) return;
channel.send({embed : embed});
});

var botid = ["491985375934283786"];
   client.on('message', message => {
       if(message.content.startsWith(`${prefix}invite`)){
           if(!message.channel.guild) return message.channel.send("This Command is Just For Servers!")
           var embed = new Discord.RichEmbed()
           .setTitle("Invite Me !.")
           .setURL(`https://discordapp.com/oauth2/authorize/?permissions=8&scope=bot&client_id=${botid}`)
           .setTimestamp()
           .setColor("RANDOM")
           message.channel.send({embed})
       }
   });

client.on('message',message => {
         if (!message.content.startsWith(prefix)) return;
var cont = message.content.slice(prefix.length).split(" ");

  var args = cont.slice(1);
       if (message.content.startsWith("!nick")) {
   let nickmention = message.mentions.users.first()
    if (message.mentions.users.size === 0) {
        if (message.member.permissions.has("CHANGE_NICKNAME")) {
            let nickchange = args.slice(0).join(" ");
            if (args[0] === undefined) {
                message.channel.send("**Ø¶Ø¹ Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯Ù‡**")
                return;
            }
            message.guild.members.get(message.author.id).setNickname(nickchange).catch(err => {
                message.channel.send("Error: " + err)
                return;
            });
            message.channel.send("âœ… **Changed your nickname to:** `" + nickchange + "`")
            return;
        } else {
            message.channel.send("You don't have permission to change your username. ğŸ˜•")
            return;
        }
        return; 
    }
    if (message.member.permissions.has("MANAGE_NICKNAMES", "ADMINISTRATOR")) {
        let nickchange = args.slice(1).join(" ");
        if (args[0] === undefined) {
            message.channel.send("**Ø¶Ø¹ Ø§Ø³Ù…**")
            return;
        }
        message.guild.members.get(nickmention.id).setNickname(nickchange).catch(err => {
            message.channel.send("Error: " + err);
            return;
        });
        message.channel.send("Nick of " + nickmention + " (" + nickmention.username + "#" + nickmention.discriminator + ") changed to: `" + nickchange + "`")
  
     }
    } 
});

client.on('message', message=> {
    if (message.author.bot) return;
    if (message.isMentioned(client.user))
    {
    message.reply(" Hi my preifx is BL! ");
    }
});

client.on('message' , message => {
  var prefix = "BL!";
  if(message.author.bot) return;
 
  if(message.content.startsWith(prefix + "xo")) {
 let array_of_mentions = message.mentions.users.array();
  let symbols = [':o:', ':heavy_multiplication_x:']
  var grid_message;
 
  if (array_of_mentions.length == 1 || array_of_mentions.length == 2) {
    let random1 = Math.floor(Math.random() * (1 - 0 + 1)) + 0;
    let random2 = Math.abs(random1 - 1);
    if (array_of_mentions.length == 1) {
      random1 = 0;
      random2 = 0;
    }
    let player1_id = array_of_mentions[random1].id;
    let player2_id = array_of_mentions[random2].id;
    var turn_id = player1_id;
    var symbol = symbols[0];
    let initial_message = `Game match between <@${player1_id}> and <@${player2_id}>!`;
    if (player1_id == player2_id) {
      initial_message += '\n_( playing this game with yourself :joy:)_'
    }
    message.channel.send(`Xo ${initial_message}`)
    .then(console.log("Successful tictactoe introduction"))
    .catch(console.error);
    message.channel.send(':one::two::three:' + '\n' +
                         ':four::five::six:' + '\n' +
                         ':seven::eight::nine:')
    .then((new_message) => {
      grid_message = new_message;
    })
    .then(console.log("Successful tictactoe game initialization"))
    .catch(console.error);
    message.channel.send('Loading... Please wait for the :ok: reaction.')
    .then(async (new_message) => {
      await new_message.react('1âƒ£');
      await new_message.react('2âƒ£');
      await new_message.react('3âƒ£');
      await new_message.react('4âƒ£');
      await new_message.react('5âƒ£');
      await new_message.react('6âƒ£');
      await new_message.react('7âƒ£');
      await new_message.react('8âƒ£');
      await new_message.react('9âƒ£');
      await new_message.react('ğŸ†—');
      await new_message.edit(`It\'s <@${turn_id}>\'s turn! Your symbol is ${symbol}`)
      .then((new_new_message) => {
        require('./xo.js')(client, message, new_new_message, player1_id, player2_id, turn_id, symbol, symbols, grid_message);
      })
      .then(console.log("Successful tictactoe listener initialization"))
      .catch(console.error);
    })
    .then(console.log("Successful tictactoe react initialization"))
    .catch(console.error);
  }
  else {
    message.reply(` :anger: \`Use : ${prefix}xo @player1 @player2\``)
    .then(console.log("Successful error reply"))
    .catch(console.error);
  }
}
 });

client.on('message', async message => {
    if(message.author.bot) return;
    if(message.channel.type === 'dm') return;
 
    var prefix = 'BL!'; //<==== ØªÙ‚Ø¯Ø± ØªØºÙŠØ± Ø§Ù„Ø¨Ø±ÙÙƒØ³
    var args = message.content.toLowerCase().split(" ");
    var command = args[0];
 
  if(command == prefix + 'bc') {
        if(!message.member.hasPermission('ADMINISTRATOR')) return message.channel.send(':no_entry: | You dont have **ADMINISTRATOR** Permission!');
        if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return message.channel.send(':no_entry: | I dont have **EMBED_LINKS** Permission!');
       
        let bcCommand = new Discord.RichEmbed()
        .setTitle(':white_check_mark: **BroadCast Command.**')
        .setColor('GREEN')
        .setDescription(`**\n${prefix}bc <MESSAGE>**\nâ¥ \`\`Send for all members the message.\`\`\n\n**${prefix}bc <ROLE> <MESSAGE>**\nâ¥ \`\`Send the message to members have the role selected.\`\`\n\n**${prefix}bc admins <MESSAGE>**\nâ¥ \`\`Send the message to members have ADMINISTRATOR permission.\`\`\n\n**${prefix}bc members <MESSAGE>**\nâ¥ \`\`Send the message to members not have ADMINISTRATOR permission.\`\``)
        .setTimestamp()
        .setFooter(message.author.tag, message.author.avatarURL)
       
        if(!args[1]) return message.channel.send(bcCommand);
       
        var getRole = message.mentions.roles.first() || message.guild.roles.find(r => r.id === args[1]) || message.guild.roles.find(r => r.name.toLowerCase().includes(args[1]));
       
        if(args[1] === 'admins' || args[1] === 'members' || getRole) {
            var argsM = message.content.split(' ').slice(2).join(' ');
        }else if(args[1] !== 'admins' || args[1] !== 'members' || !getRole) {
            var argsM = message.content.split(' ').slice(1).join(' ');
        }
       
        if(args[1] === 'admins' || args[1] === 'members') {
            if(args[1] === 'admins') {
                var admin = message.guild.members.filter(m => m.hasPermission('ADMINISTRATOR') && !m.user.bot);
                if(admin.size <= 1) return message.channel.send(':no_entry: | No admins in this server!');
               
                let notArgsM = new Discord.RichEmbed()
                .setTitle(':white_check_mark: **BroadCast Command.** (ADMINISTRATOR)')
                .setColor('GREEN')
                .setDescription(`**\n${prefix}bc admins <MESSAGE>**\nâ¥ \`\`Send the message to members have ADMINISTRATOR permission.\`\``)
                .setTimestamp()
                .setFooter(message.author.tag, message.author.avatarURL)
               
                if(!argsM) return message.channel.send(notArgsM);
               
                let adminMsg = new Discord.RichEmbed()
                .setTitle(':white_check_mark: **BroadCast Command.** (ADMINISTRATOR)')
                .setColor('GREEN')
                .setDescription(`**\n**:red_circle: Are you sure to send the message to **${admin.size}** Admins?\n\n**â¥ Message:**\n${argsM}`)
                .setTimestamp()
                .setFooter(message.author.tag, message.author.avatarURL)
               
                message.channel.send(adminMsg).then(msgB => {
                    msgB.react('âœ…').then(() => msgB.react('â'))
                   
                    let sendR = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                    let dontSendR = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                    let send = msgB.createReactionCollector(sendR);
                    let dontSend = msgB.createReactionCollector(dontSendR);
                   
                    send.on('collect', r => {
                        msgB.delete();
                        message.channel.send(`:timer: | Wait some time to send the message to **${admin.size}** Admins ...`).then(msg => {
                            admin.forEach(async a => {
                                let bcMessage = new Discord.RichEmbed()
                                .setTitle(`:loudspeaker: ${a.user.username}`)
                                .setColor('GREEN')
                                .addField(':pencil: **Sender:**', message.author.username, true)
                                .addField(':globe_with_meridians: **Server:**', message.guild.name, true)
                                .addField(':scroll: **Message:**', argsM.replace('[user]', a))
                                .setTimestamp()
                                .setFooter(message.author.tag, message.author.avatarURL)
                               
                                a.send(bcMessage)
                                await msg.edit(`:white_check_mark: | <@${message.author.id}> Successfully send the message to **${admin.size}** Admins!`);
                            })
                        })
                    })
                    dontSend.on('collect', r => {
                        msgB.delete();
                        message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                    })
                })
            }else if(args[1] === 'members') {
                var member = message.guild.members.filter(m => !m.hasPermission('ADMINISTRATOR') && !m.user.bot);
                if(member.size === 0) return message.channel.send(':no_entry: | No members in this server!');
               
                let notArgsM = new Discord.RichEmbed()
                .setTitle(':white_check_mark: **BroadCast Command.** (MEMBER)')
                .setColor('GREEN')
                .setDescription(`**\n${prefix}bc members <MESSAGE>**\nâ¥ \`\`Send the message to members not have ADMINISTRATOR permission.\`\``)
                .setTimestamp()
                .setFooter(message.author.tag, message.author.avatarURL)
               
                if(!argsM) return message.channel.send(notArgsM);
               
                let memberMsg = new Discord.RichEmbed()
                .setTitle(':white_check_mark: **BroadCast Command.** (MEMBER)')
                .setColor('GREEN')
                .setDescription(`**\n**:red_circle: Are you sure to send the message to **${member.size}** Members?\n\n**â¥ Message:**\n${argsM}`)
                .setTimestamp()
                .setFooter(message.author.tag, message.author.avatarURL)
               
                message.channel.send(memberMsg).then(msgB => {
                    msgB.react('âœ…').then(() => msgB.react('â'))
                   
                    let sendR = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                    let dontSendR = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                    let send = msgB.createReactionCollector(sendR);
                    let dontSend = msgB.createReactionCollector(dontSendR);
                   
                    send.on('collect', r => {
                        msgB.delete();
                        message.channel.send(`:timer: | Wait some time to send the message to **${member.size}** Members ...`).then(msg => {
                            member.forEach(async m => {
                                let bcMessage = new Discord.RichEmbed()
                                .setTitle(`:loudspeaker: ${m.user.username}`)
                                .setColor('GREEN')
                                .addField(':pencil: **Sender:**', message.author.username, true)
                                .addField(':globe_with_meridians: **Server:**', message.guild.name, true)
                                .addField(':scroll: **Message:**', argsM.replace('[user]', m))
                                .setTimestamp()
                                .setFooter(message.author.tag, message.author.avatarURL)
                               
                                m.send(bcMessage)
                                await msg.edit(`:white_check_mark: | <@${message.author.id}> Successfully send the message to **${member.size}** Members!`);
                            })
                        })
                    })
                    dontSend.on('collect', r => {
                        msgB.delete();
                        message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                    })
                })
            }
        }else if(getRole) {
            var membersRole = message.guild.members.filter(m => m.roles.has(getRole.id) && !m.user.bot);
            if(membersRole.size === 0) return message.channel.send(`:no_entry: | No members have **${getRole.name}** Role!`);
           
            let notArgsM = new Discord.RichEmbed()
            .setTitle(`:white_check_mark: **BroadCast Command.** (${getRole.name})`)
            .setColor('GREEN')
            .setDescription(`**\n${prefix}bc <ROLE> <MESSAGE>**\nâ¥ \`\`Send the message to members have the role selected.\`\``)
            .setTimestamp()
            .setFooter(message.author.tag, message.author.avatarURL)
           
            if(!argsM) return message.channel.send(notArgsM);
           
            let membersRoleMsg = new Discord.RichEmbed()
            .setTitle(`:white_check_mark: **BroadCast Command.** (${getRole.name})`)
            .setColor('GREEN')
            .setDescription(`**\n**:red_circle: Are you sure to send the message to **${membersRole.size}** Members?\n\n**â¥ Message:**\n${argsM}`)
            .setTimestamp()
            .setFooter(message.author.tag, message.author.avatarURL)
           
            message.channel.send(membersRoleMsg).then(msgB => {
                msgB.react('âœ…').then(() => msgB.react('â'))
               
                let sendR = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                let dontSendR = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                let send = msgB.createReactionCollector(sendR);
                let dontSend = msgB.createReactionCollector(dontSendR);
               
                send.on('collect', r => {
                    msgB.delete();
                    message.channel.send(`:timer: | Wait some time to send the message to **${membersRole.size}** Members ...`).then(msg => {
                        membersRole.forEach(async mR => {
                            let bcMessage = new Discord.RichEmbed()
                            .setTitle(`:loudspeaker: ${mR.user.username}`)
                            .setColor('GREEN')
                            .addField(':pencil: **Sender:**', message.author.username, true)
                            .addField(':globe_with_meridians: **Server:**', message.guild.name, true)
                            .addField(':scroll: **Message:**', argsM.replace('[user]', mR))
                            .setTimestamp()
                            .setFooter(message.author.tag, message.author.avatarURL)
                           
                            mR.send(bcMessage)
                            await msg.edit(`:white_check_mark: | <@${message.author.id}> Successfully send the message to **${membersRole.size}** Members!`);
                        })
                    })
                })
                dontSend.on('collect', r => {
                    msgB.delete();
                    message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                })
            })
        }else if(args[1] !== 'admins' && args[1] !== 'members' && !getRole) {
            var allB = message.guild.members.filter(m => !m.user.bot);
            if(allB.size === 1) return message.channel.send(`:no_entry: | No members in this server!`);
           
            let allMsg = new Discord.RichEmbed()
            .setTitle(`:white_check_mark: **BroadCast Command.** (ALL)`)
            .setColor('GREEN')
            .setDescription(`**\n**:red_circle: Are you sure to send the message to **${allB.size}** Members?\n\n**â¥ Message:**\n${argsM}`)
            .setTimestamp()
            .setFooter(message.author.tag, message.author.avatarURL)
           
            message.channel.send(allMsg).then(msgB => {
                msgB.react('âœ…').then(() => msgB.react('â'))
               
                let sendR = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                let dontSendR = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                let send = msgB.createReactionCollector(sendR);
                let dontSend = msgB.createReactionCollector(dontSendR);
               
                send.on('collect', r => {
                    msgB.delete();
                    message.channel.send(`:timer: | Wait some time to send the message to **${allB.size}** Members ...`).then(msg => {
                        membersRole.forEach(async m => {
                            let bcMessage = new Discord.RichEmbed()
                            .setTitle(`:loudspeaker: ${m.user.username}`)
                            .setColor('GREEN')
                            .addField(':pencil: **Sender:**', message.author.username, true)
                            .addField(':globe_with_meridians: **Server:**', message.guild.name, true)
                            .addField(':scroll: **Message:**', argsM.replace('[user]', m))
                            .setTimestamp()
                            .setFooter(message.author.tag, message.author.avatarURL)
                           
                            m.send(bcMessage)
                            await msg.edit(`:white_check_mark: | <@${message.author.id}> Successfully send the message to **${allB.size}** Members!`);
                        })
                    })
                })
                dontSend.on('collect', r => {
                    msgB.delete();
                    message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                })
            })
        }
    }
});

client.login(process.env.BOT_TOKEN);
